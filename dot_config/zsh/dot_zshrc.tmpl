# Environment detection
. "$ZDOTDIR"/.detect_env

# Use shallow clone on transient machines
smart_clone() {
  if [[ -n "$CODESPACES" || -n "$GITHUB_CODESPACES" || -n "$GITPOD_WORKSPACE_ID" ]]; then
    echo clone --depth=1
  else
    echo clone
  fi
}

. "$ZDOTDIR"/.zsh_util_install

is_gnu_sed() {
  sed --version &> /dev/null
}

if ! is_gnu_sed; then
  if command -v gsed &> /dev/null; then
    alias sed=gsed
  else
    unalias sed 2>/dev/null  # Remove any existing alias
    sed() {
      # Modify GNU-style arguments to make sense to BSD sed
      local args=()

      for arg in "$@"; do
        case "$arg" in
          -r|--regexp-extended)
            args+=(-E)
            ;;
          -i)
            # BSD sed requires empty string after -i for in-place editing
            args+=(-i '')
            ;;
          -i*)
            # Handle -i with suffix (e.g., -i.bak)
            args+=("$arg")
            ;;
          *)
            args+=("$arg")
            ;;
        esac
      done

      command sed "${args[@]}"
    }
  fi
fi

# mise
if command -v mise &> /dev/null; then
  eval "$(mise activate zsh)"
  # eval "$(mise activate zsh --shims)"
  if ! command -v usage &> /dev/null; then
    mise use -g usage
  fi
fi

if [ ! -d "$XDG_CACHE_HOME"/zsh ]; then
  mkdir -p "$XDG_CACHE_HOME"/zsh
fi
export ZSH_CACHE_DIR="$XDG_CACHE_HOME/zsh"

# Topic config
ZSH_TOPICFILE="$ZDOTDIR/zsh-topics"
typeset -A topics

init_topics() {
  if [[ ! -s "$ZSH_TOPICFILE" ]]; then
    # Define default config here
    > "$ZSH_TOPICFILE" <<CONFIG
# elm
# java
# js
# ruby
CONFIG
  fi

  # Read topics
  for topic in "${(f)"$(<$ZSH_TOPICFILE)"}"; do
    if [[ ! $topic =~ '^#' ]]; then
      topics+=("$topic" 1)
    fi
  done

  unset topic
}

init_topics

purge_topics() {
  rm "$ZSH_TOPICFILE"
}

for topic enabled in "${(@kv)topics}"; do
  if [[ $enabled == 1 ]]; then
    source "$ZDOTDIR"/topics/"$topic".zsh
  fi
done
unset topic
unset enabled

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.config/zsh/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Clone zcomet if necessary
if [[ ! -f ${ZDOTDIR:-${HOME}}/.zcomet/bin/zcomet.zsh ]]; then
  git $(smart_clone) https://github.com/agkozak/zcomet.git ${ZDOTDIR:-${HOME}}/.zcomet/bin
fi

source ${ZDOTDIR:-${HOME}}/.zcomet/bin/zcomet.zsh

# Add manual completions and functions to fpath
fpath=( "$ZDOTDIR"/completions "$ZDOTDIR"/functions "${fpath[@]}" )
fpath=(/Users/hbotha/.docker/completions $fpath)

typeset -a omz_plugins
omz_plugins=(
  # 'plugins/mise'
  'plugins/vi-mode'
)

typeset -a plugins
plugins=(
  'romkatv/powerlevel10k'
  'Aloxaf/fzf-tab'
  'olets/zsh-abbr'
  'olets/zsh-test-runner'
  'romkatv/zsh-bench'
  # Zcomet recommends loading this last
  'zsh-users/zsh-autosuggestions'
)

if [[ ! -d "$ZDOTDIR"/.zcomet/repos/ohmyzsh/ohmyzsh ]]; then
  git $(smart_clone) https://github.com/ohmyzsh/ohmyzsh.git "$ZDOTDIR"/.zcomet/repos/ohmyzsh/ohmyzsh
fi

for plugin in "${omz_plugins[@]}"; do
  zcomet load ohmyzsh "$plugin"
done

for plugin in "${plugins[@]}"; do
  if [[ ! -d "$ZDOTDIR"/.zcomet/repos/"$plugin" ]]; then
    git $(smart_clone) --recurse-submodules https://github.com/"$plugin".git "$ZDOTDIR"/.zcomet/repos/"$plugin"
  fi
  zcomet load "$plugin"
done

zcomet compinit

# Load any available Bash completions.
autoload -U +X bashcompinit && bashcompinit

# Load dynamic completion functions
autoload -Uz _dynamic_completions _completion_fallback

# This needs to go after all calls to compinit.
enable-fzf-tab

which-alias() {
  which $(alias $1 | sed -E 's/^.+=//')
}

# Append "$1" to $PATH when not already in.
append_path() {
  case ":$PATH:" in
    *:"$1":*)
      ;;
    *)
      PATH="${PATH:+$PATH:}$1"
  esac
}

export PATH

append_path "$HOME/.local/bin"
append_path "$ZDOTDIR/tools"

. "$ZDOTDIR"/config/history.zsh
. "$ZDOTDIR"/config/keybinds.zsh

# Case-insensitive (all), partial word and then substring completion
# https://github.com/nickmccurdy/sane-defaults/blob/1f6d632/home/.zshrc#L12
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
setopt no_list_ambiguous

# Key bindings for fzf-tab
zstyle ':fzf-tab:*' fzf-bindings 'right:accept'
# Use 16 colours, because fzf-tab ignores FZF_DEFAULT_OPTS
zstyle ':fzf-tab:*' fzf-flags --color=16

zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,comm -w -w"
zstyle ':fzf-tab:complete:(kill|ps):argument-rest' fzf-preview \
  '[[ $group == "[process ID]" ]] && ps --pid=$word -o cmd --no-headers -w -w'
zstyle ':fzf-tab:complete:(kill|ps):argument-rest' fzf-flags --preview-window=down:3:wrap

zstyle ':fzf-tab:complete:systemctl-*:*' fzf-preview 'SYSTEMD_COLORS=1 systemctl status $word'
# zstyle ':fzf-tab:complete:brew-services-*:*' fzf-preview 'SYSTEMD_COLORS=1 brew services status $word'

zstyle ':fzf-tab:complete:brew-(install|uninstall|search|info):*-argument-rest' fzf-preview 'HOMEBREW_COLOR=1 brew info $word'

zstyle ':fzf-tab:complete:(-command-|-parameter-|-brace-parameter-|export|unset|expand):*' \
  fzf-preview 'echo ${(P)word}'

if [ -d ~/zsh_help ]; then
  export HELPDIR=~/zsh_help
  unalias run-help
  autoload run-help
fi

alias help=run-help

alias s=". $ZDOTDIR/.zshrc"
alias :q=exit # Welp

alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -I'

setopt extended_glob
# Allow **foo as shorthand for **/*foo.
setopt glob_star_short
# Resolve symlinks & dots (..) to their true absolute path.
setopt chase_links

setopt auto_pushd
export DIRSTACKSIZE=10

alias dv='dirs -v'

# On dir change, run a function that, if we're in
# ~/git_tree/agency-api-client/$branch_name, will add the subdirs of ./packages
# to $cdpath.
# TODO: Generalise this to read from a map of directory patterns to "package" dirs.
chpwd_functions=($chpwd_functions chpwd_add_packages)
chpwd_add_packages() {
  if [[ $(pwd) =~ "$HOME"'/git_tree/attractions/content/([A-Za-z0-9_-]+)/?\b' ]]; then
    package_dir="$HOME"'/git_tree/attractions/content/'$match[1]'/packages'
    if [[ ! ${cdpath[(ie)$package_dir]} -le ${#cdpath} ]]; then
      cdpath=($cdpath $package_dir)
    fi
  else
    # Remove things that look like package_dir from cdpath
    cdpath=(${cdpath:#"$HOME"'/git_tree/attractions/content/'$match[1]'/packages'})
  fi
}

# chpwd is not invoked on shell startup, so we define a self-destructing
# function to do this once. Source:
# https://gist.github.com/laggardkernel/b2cbc937aa1149530a4886c8bcc7cf7c
_self_destruct_hook() {
  local f
  for f in ${chpwd_functions}; do
    "$f"
  done

  # Remove self from precmd
  precmd_functions=(${(@)precmd_functions:#_self_destruct_hook})
  builtin unfunction _self_destruct_hook
}
(( $+functions[add-zsh-hook] )) || autoload -Uz add-zsh-hook
add-zsh-hook precmd _self_destruct_hook

# Zsh global aliases
alias -g @q="2> /dev/null"
alias -g @qq="&> /dev/null"
alias -g @errout="2>&1"

# Docker
alias d=docker
alias dc=docker-compose

# Kubernetes
[ -f "$HOME/.kubectl.zsh" ] && . "$HOME/.kubectl.zsh"
alias k=kubectl

# Git
alias g='git'

# mise
alias m=mise

# A lovely script that watches files for changes and automatically commits them
# to git. Nice to use for note-taking.
autocommit() {
  # commit any changes since last run
  date +%Y-%m-%dT%H:%M:%S%z; git add $@; git commit -m "AUTOCOMMIT"; echo
  # now commit changes whenever files are saved
  fswatch -0 $@ | xargs -0 -n 1 sh -c "date +%Y-%m-%dT%H:%M:%S%z; git add .; git commit -m \"AUTOCOMMIT\"; echo"
}

# Tmux
# Let's install tpm, if we have Tmux but not tpm
if [ -d "$HOME/.tmux" -a ! -d "$HOME/.tmux/plugins/tpm" ]; then
  git $(smart_clone) git@github.com:tmux-plugins/tpm.git ~/.tmux/plugins/tpm
fi

alias tx='tmuxinator s'
alias txe='tmuxinator new'
alias ta='tmux a -t'
alias tai='tmux new-session -t' # mnemonic: "tmux attach independent"
alias tk='tmux kill-session -t'
alias tl='tmux ls 2> /dev/null || echo '\''Tmux is not running.'\'
typeset -A tmux_sessions
export tmux_sessions=(
  [dev]=~/git_tree
  [diy]=~/Documents/DIY
  [dotfiles]=~/.local/share/chezmoi
  [games]=~/Games
  [notes]=~/git_tree/notes
  [personal-dev]=~/dev
)
tn() {
  : ${1:?tn needs a session name.}
  args=(${@:2})
  session_root=${tmux_sessions[$1]:-$HOME}
  tmux has-session -t $1 2> /dev/null
  if [ $? != 0 ]; then
    tmux new-session -d -s $1 -c $session_root $args
  fi
  if [[ -n "$TMUX_PANE" ]]; then
    tmux switch-client -t $1
  else
    tmux attach -t $1
  fi
}
tna() {
  auto_sessions=(
    dev
    dotfiles
    notes
    personal-dev
  )
  for session in ${(@k)tmux_sessions:*auto_sessions}; do
    tn $session -d
  done
}

# Wait for a string to appear in another pane before executing a command
tmux_await() {
  # Args: window & pane (ints), then grep pattern to match, then command to run
  : ${1:?tmux_await needs a window number (prefix-i).}
  : ${2:?tmux_await needs a pane number (prefix-i or prefix-q).}
  : ${3:?tmux_await needs a pattern to look for.}
  : ${4:?tmux_await needs a command to execute.}
  while ! tmux capture-pane -p -t @"$1".%"$2" | grep "$3"; do
    sleep 1
  done; ${@:4}
}

# Function to view command output in a tmux popup pager
tpage() {
  if command -v tmux &> /dev/null; then
    tmux display-popup -w 80% -h 80% -xC -yC "$@"
  else
    # Fallback if not in tmux or tmux not available
    "$@" | less
  fi
}

# Example usage:
# tpage ls -l /usr/local/bin
# tpage dmesg | grep -i "error"

# Fix broken mouse reporting after ssh exits abruptly
alias fix-mouse-reporting='printf '\''\e[?1000l'\'''

# Vim
if command -v vim &> /dev/null; then
  # If we're in a Git repo, name the server after that repo. Otherwise, give it a
  # misc name, based either on Tmux session or otherwise just "VIM".
  vim_servername() {
    if git rev-parse --is-inside-work-tree &> /dev/null; then
      echo "$(git repo-and-branch-name)"
    elif [ -n "$TMUX" ]; then
      echo "$(tmux display-message -p '#{session_name}')"
    else
      echo 'VIM'
    fi
  }
  # Launch with -X to prevent communication with X11 on startup, improving startup
  # speed in Tmux
  if vim --version | grep '+clientserver' > /dev/null; then
    alias vim='vim -X --servername $(vim_servername)'
  else
    alias vim='vim -X'
  fi
  # Use as pager
  alias vpage='ifne vim -X -R - -n'
  # Source ~/.vimrc in every running Vim server instance
  alias vu='for server in `vim --serverlist`; do; vim --servername $server --remote-send '\'':source ~/.vimrc<cr>'\''; done'
fi

# Ripgrep
rgl() {
  rg --color=always $@ | less -R
}

eval "fzfcp() {
  fzf -m --tac \$@ | ${DOTFILES_ENV[CLIPBOARD_CMD]}
}"

alias fzfd='fd -t d | fzf'

# ---

# Kill whatever process is holding the given port(s).
portkill() {
  # kill -9 $(lsof -t -i :3001 -i :3002) etc is a better syntax
  : ${1:?portkill needs at least one port (e.g. '3000').}
  for i in $@; do; kill -9 $(lsof -t -i :"$i"); done
}

# ---

# macOS
if [[ "${DOTFILES_ENV[OS]}" == 'Darwin' ]]; then
  # Fix the macOS pasteboard when it breaks
  alias fixpboard='pkill -9 pboard'

  alias ip-eth="ipconfig getifaddr en0"
  alias ip-wifi="ipconfig getifaddr en1"
fi

alias s='sudo'

# Default 400ms delay after ESC is too slow. Increase this value if this breaks
# other commands that depend on the delay.
export KEYTIMEOUT=1 # 100 ms

# Completion
# Allow tab completion to match hidden files always
setopt globdots

# Misc
if command -v eza &> /dev/null; then
  # -F cannot come before other bundled single-char flags
  alias ls='eza -alF --git --group-directories-first --time-style=long-iso'
  alias l=ls
  alias ld='ls -D'
  alias tree='eza -alTF --git --time-style=long-iso'
  alias t=tree
elif command -v exa &> /dev/null; then
  alias ls='exa -aFl --git --group-directories-first --time-style=long-iso'
  alias l=ls
  alias ld='ls -D'
  alias tree='exa -aFlT --git --time-style=long-iso'
  alias t=tree
else
  alias ls='ls -Ahlp --color=auto --group-directories-first --hyperlink --time-style=long-iso'
  alias l=ls
  alias ld='ls -Ahl --color=auto --directory --hyperlink --time-style=long-iso'
  alias t=tree
fi

export RIPGREP_CONFIG_PATH="$HOME"'/.ripgreprc'

# fzf keybinds/completion
if command -v fzf &> /dev/null; then
  eval "$(fzf --zsh)"
  [ -f "$ZDOTDIR/.fzf.zsh" ] && . "$ZDOTDIR/.fzf.zsh"
fi

# Zsh-autosuggestions
export ZSH_AUTOSUGGEST_USE_ASYNC=1

if command -v atuin &> /dev/null; then
  eval "$(atuin init zsh --disable-up-arrow)"
  bindkey -M vicmd '^r' atuin-search
  bindkey -M viins '^r' atuin-search
  bindkey -M visual '^r' atuin-search
fi

export FZF_DEFAULT_OPTS='--color=16 --bind "f1:execute(less -f {})"'
# --files: List files, do not search them
# --follow: Follow symlinks
# --hidden: Search hidden paths
# --glob: Additional conditions (exclude .git)
# --no-ignore: Do not respect .gitignore and the like
export FZF_DEFAULT_COMMAND='rg --files --glob '\''!.git/*'\'' --hidden --no-ignore'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND=altc

alias fzfp='fzf --preview '\''[[ $(file --mime {}) =~ binary ]] &&
                 echo {} is a binary file ||
                 (highlight -O ansi -l {} ||
                  coderay {} ||
                  rougify {} ||
                  cat {}) 2> /dev/null | head -200'\'

fh() {
  print -z $( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | fzf +s --tac | sed 's/ *[0-9]* *//')
}

# OPAM configuration
[ -f "$HOME"/.opam/opam-init/init.zsh ] && . "$HOME"/.opam/opam-init/init.zsh

load_tmux_user_env() {
  if [ -n "$TMUX" ]; then
    local start_time=$EPOCHREALTIME

    # Capture the output of the tmux command
    local tmux_env_output
    tmux_env_output=$(tmux show-environment | sed -n '/^TMUX_USER_ENV_/ s/^TMUX_USER_ENV_//p')

    local end_time=$EPOCHREALTIME
    local duration
    duration=$(($end_time - $start_time))

    # Define the threshold in seconds (0.75s = 750ms)
    local threshold=0.75

    # Check if the execution time exceeded the threshold
    if (( duration > threshold )); then
      # Print a warning to stderr so it doesn't interfere with other commands.
      # The colors make it easy to spot.
      print -Pr -- "%F{yellow}WARNING:%f tmux environment load took %F{red}${duration}s%f (threshold: ${threshold}s)" >&2
    fi

    # Process the captured output
    for var in ${(f)tmux_env_output}; do
      export $var
    done
  fi
}
load_tmux_user_env
add-zsh-hook preexec load_tmux_user_env

# Registry-based environment serialisation
DOTFILES_ENV_REGISTRY="$HOME/.cache/zsh/dotfiles_env_registry"
_dotfiles_env_needs_export=0

# Ensure registry directory exists
[[ ! -d "${DOTFILES_ENV_REGISTRY%/*}" ]] && mkdir -p "${DOTFILES_ENV_REGISTRY%/*}"

# Read registry into associative array for fast lookup
typeset -A _dotfiles_env_allowlist
_load_env_registry() {
  _dotfiles_env_allowlist=()
  [[ -f "$DOTFILES_ENV_REGISTRY" ]] && {
    local tool
    while read -r tool; do
      [[ -n "$tool" ]] && _dotfiles_env_allowlist[$tool]=1
    done < "$DOTFILES_ENV_REGISTRY"
  }
}

# Load registry on startup
_load_env_registry

# Mark that export is needed (very fast)
_mark_env_dirty() {
  _dotfiles_env_needs_export=1
}

# Actually serialise only when needed
_ensure_env_exported() {
  if (( _dotfiles_env_needs_export )); then
    local -a kv=("${(@kv)DOTFILES_ENV}")
    export DOTFILES_ENV_SERIALISED="${(j: :)kv[@]/(#m)*/${MATCH%% *}=${MATCH##* }}"
    _dotfiles_env_needs_export=0
  fi
}

# Ultra-lightweight preexec with allowlist
preexec_dotfiles_env() {
  local cmd="${1%% *}"

  # Only serialise for registered tools
  [[ -n "${_dotfiles_env_allowlist[$cmd]}" ]] && _mark_env_dirty
}

add-zsh-hook preexec preexec_dotfiles_env

# Print ellipsis while completing, and load Tmux user variables before completing.
expand-or-complete-custom() {
  # https://github.com/ohmyzsh/ohmyzsh/blob/02d07f3e3dba0d50b1d907a8062bbaca18f88478/lib/completion.zsh#L62
  print -Pn "%F{red}â€¦%f"
  load_tmux_user_env
  zle fzf-tab-complete
  zle redisplay
}

zle -N expand-or-complete-custom
bindkey -M emacs "^I" expand-or-complete-custom
bindkey -M viins "^I" expand-or-complete-custom
bindkey -M vicmd "^I" expand-or-complete-custom

[ -f "$ZDOTDIR"/.zsh-work ] && . "$ZDOTDIR"/.zsh-work

typeset -A global_aliases
export global_aliases=(
  ['@q']='2> /dev/null'
  ['@qq']='&> /dev/null'
  ['@errout']='2>&1'
  ['@kshell']='sh -c "echo '\''$(base64 -i ~/.kshellrc)'\'' | base64 -d > /tmp/.bashrc && exec bash --rcfile /tmp/.bashrc"'
)

if command -v abbr &> /dev/null; then
  abbr-add() {
    : ${1:?abbr-add needs an abbreviation (e.g. 'apt iy').}
    : ${2:?abbr-add needs an expansion (e.g. 'apt install -y').}
    abbr "$1"="$2"
    abbr -g "@$1"="$2"
  }

  abbr-bulk-erase() {
    : ${1:?abbr-bulk-erase needs at least one abbreviation (e.g. 'apt iy' 'apt i').}
    for i in $@; do; abbr erase "$i"; abbr erase -g "@$i"; done
  }

  ABBR_SET_EXPANSION_CURSOR=1
  ABBR_EXPANSION_CURSOR_MARKER='#'
  ABBR_REGULAR_ABBREVIATION_SCALAR_PREFIXES=('man ' 'noglob ' 'sudo ' 'watch ' 'which ')
  ABBR_REGULAR_ABBREVIATION_GLOB_PREFIXES=('-* ')

  typeset -A abbr_abbreviations
  export abbr_abbreviations=(
    ['a']='apt'
    ['ai']='apt install'
    ['apt i']='apt install'
    ['aiy']='apt install -y'
    ['apt iy']='apt install -y'
    ['apt install y']='apt install -y'
    [c]=chezmoi
    ['chezmoi a']='chezmoi add'
    ['chezmoi d']='chezmoi diff'
    ['chezmoi i']='chezmoi ignored'
    ['chezmoi m']='chezmoi managed'
    ['chezmoi s']='chezmoi status'
    ['chezmoi u']='chezmoi unmanaged'
    [d]=docker
    [dv]='dirs -v'
    [e]=emacs
    [fzfcp]='fzf #| '"$(echo $clip)"
    [fzfd]='fd -t d | fzf'
    [g]=git
    [gclr]='gron -c | less -R'
    [k]=kubectl
    ['kubectl e']='kubectl exec $pod -it --'
    ['kubectl gp']='kubectl get pods'
    ['kubectl g']='kubectl get'
    ['kubectl get p']='kubectl get pods'
    ['kubectl l']='kubectl logs -c app $pod'
    ['kubectl lf']='kubectl logs -c app --tail=20 -f $pod'
    ['kubectl pf']='kubectl port-forward services/$service 8080:$port'
    [l]=ls
    [m]=mise
    [s]=sudo
    [t]=tree
    [dts]='date +"%Y-%m-%dT%H:%M:%S"'
    [v]=vim
    [wa]='watch -c'
    [wh]=which
  )

  abbrs=$(abbr list-abbreviations)
  for abbreviation phrase in ${(@kv)abbr_abbreviations}; do
    if [[ ! "$abbrs" =~ "\"$abbreviation\"" ]]; then
      abbr "$abbreviation"="$phrase" > /dev/null
    fi
    if [[ ! "$abbrs" =~ "\"@$abbreviation\"" ]]; then
      abbr -g "@$abbreviation"="$phrase" > /dev/null
    fi
  done
  unset abbrs
  unset abbr_abbreviations

  global_abbrs=$(abbr list-abbreviations)
  for abbreviation phrase in ${(@kv)global_aliases}; do
    if [[ ! "$global_abbrs" =~ "\"$abbreviation\"" ]]; then
      abbr -g "$abbreviation"="$phrase" > /dev/null
    fi
  done
  unset global_abbrs
  unset global_aliases

  bindkey "^E" abbr-expand
else
  for abbreviation phrase in ${(@kv)global_aliases}; do
    alias -g "$abbreviation"="$phrase"
  done
fi
unset global_aliases

repl() {
  : ${1:?repl needs a language name (js, python2, ruby, etc).}
  case $1 in
    node|javascript|js)
      node;;
    java)
      jshell;;
    python)
      python;;
    python2)
      python2;;
    python3)
      python3;;
    ruby)
      if command -v rbenv &> /dev/null; then
        if rbenv which pry &> /dev/null; then
          pry
        else
          irb
        fi
      else
        if command -v pry &> /dev/null; then
          pry
        else
          irb
        fi
      fi;;
    *)
      echo 'Unrecognised language. Pick one of: node|javascript|js, java, python[2|3], ruby'
      return 1;;
  esac
}

export LOCALE_ARCHIVE=/usr/lib/locale/locale-archive

# To customize prompt, run `p10k configure` or edit ~/.config/zsh/.p10k.zsh.
[[ ! -f ~/.config/zsh/.p10k.zsh ]] || source ~/.config/zsh/.p10k.zsh
[[ ! -f ~/.config/zsh/.p10k-tmux.zsh ]] || source ~/.config/zsh/.p10k-tmux.zsh

# zprof
# zmodload -u zsh/zprof
